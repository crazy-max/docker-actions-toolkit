// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.1
//   protoc               v3.11.4
// source: api/services/control/control.proto

/* eslint-disable */
import * as _m0 from "protobufjs/minimal";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";
import { Status } from "../../../github.com/gogo/googleapis/google/rpc/status";
import { BuildkitVersion, WorkerRecord } from "../../../github.com/moby/buildkit/api/types/worker";
import { Definition, ProgressGroup, Range, SourceInfo } from "../../../github.com/moby/buildkit/solver/pb/ops";
import { Policy } from "../../../github.com/moby/buildkit/sourcepolicy/pb/policy";
import { Timestamp } from "../../../google/protobuf/timestamp";
import Long = require("long");

export const protobufPackage = "moby.buildkit.v1";

export enum BuildHistoryEventType {
  STARTED = 0,
  COMPLETE = 1,
  DELETED = 2,
  UNRECOGNIZED = -1,
}

export function buildHistoryEventTypeFromJSON(object: any): BuildHistoryEventType {
  switch (object) {
    case 0:
    case "STARTED":
      return BuildHistoryEventType.STARTED;
    case 1:
    case "COMPLETE":
      return BuildHistoryEventType.COMPLETE;
    case 2:
    case "DELETED":
      return BuildHistoryEventType.DELETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return BuildHistoryEventType.UNRECOGNIZED;
  }
}

export function buildHistoryEventTypeToJSON(object: BuildHistoryEventType): string {
  switch (object) {
    case BuildHistoryEventType.STARTED:
      return "STARTED";
    case BuildHistoryEventType.COMPLETE:
      return "COMPLETE";
    case BuildHistoryEventType.DELETED:
      return "DELETED";
    case BuildHistoryEventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface PruneRequest {
  filter: string[];
  all: boolean;
  keepDuration: number;
  keepBytes: number;
}

export interface DiskUsageRequest {
  filter: string[];
}

export interface DiskUsageResponse {
  record: UsageRecord[];
}

export interface UsageRecord {
  ID: string;
  Mutable: boolean;
  InUse: boolean;
  Size: number;
  /** @deprecated */
  Parent: string;
  CreatedAt: Date | undefined;
  LastUsedAt: Date | undefined;
  UsageCount: number;
  Description: string;
  RecordType: string;
  Shared: boolean;
  Parents: string[];
}

export interface SolveRequest {
  Ref: string;
  Definition:
    | Definition
    | undefined;
  /**
   * ExporterDeprecated and ExporterAttrsDeprecated are deprecated in favor
   * of the new Exporters. If these fields are set, then they will be
   * appended to the Exporters field if Exporters was not explicitly set.
   */
  ExporterDeprecated: string;
  ExporterAttrsDeprecated: { [key: string]: string };
  Session: string;
  Frontend: string;
  FrontendAttrs: { [key: string]: string };
  Cache: CacheOptions | undefined;
  Entitlements: string[];
  FrontendInputs: { [key: string]: Definition };
  /** Internal builds are not recorded in build history */
  Internal: boolean;
  SourcePolicy: Policy | undefined;
  Exporters: Exporter[];
}

export interface SolveRequest_ExporterAttrsDeprecatedEntry {
  key: string;
  value: string;
}

export interface SolveRequest_FrontendAttrsEntry {
  key: string;
  value: string;
}

export interface SolveRequest_FrontendInputsEntry {
  key: string;
  value: Definition | undefined;
}

export interface CacheOptions {
  /**
   * ExportRefDeprecated is deprecated in favor or the new Exports since BuildKit v0.4.0.
   * When ExportRefDeprecated is set, the solver appends
   * {.Type = "registry", .Attrs = ExportAttrs.add("ref", ExportRef)}
   * to Exports for compatibility. (planned to be removed)
   */
  ExportRefDeprecated: string;
  /**
   * ImportRefsDeprecated is deprecated in favor or the new Imports since BuildKit v0.4.0.
   * When ImportRefsDeprecated is set, the solver appends
   * {.Type = "registry", .Attrs = {"ref": importRef}}
   * for each of the ImportRefs entry to Imports for compatibility. (planned to be removed)
   */
  ImportRefsDeprecated: string[];
  /**
   * ExportAttrsDeprecated is deprecated since BuildKit v0.4.0.
   * See the description of ExportRefDeprecated.
   */
  ExportAttrsDeprecated: { [key: string]: string };
  /** Exports was introduced in BuildKit v0.4.0. */
  Exports: CacheOptionsEntry[];
  /** Imports was introduced in BuildKit v0.4.0. */
  Imports: CacheOptionsEntry[];
}

export interface CacheOptions_ExportAttrsDeprecatedEntry {
  key: string;
  value: string;
}

export interface CacheOptionsEntry {
  /** Type is like "registry" or "local" */
  Type: string;
  /**
   * Attrs are like mode=(min,max), ref=example.com:5000/foo/bar .
   * See cache importer/exporter implementations' documentation.
   */
  Attrs: { [key: string]: string };
}

export interface CacheOptionsEntry_AttrsEntry {
  key: string;
  value: string;
}

export interface SolveResponse {
  ExporterResponse: { [key: string]: string };
}

export interface SolveResponse_ExporterResponseEntry {
  key: string;
  value: string;
}

export interface StatusRequest {
  Ref: string;
}

export interface StatusResponse {
  vertexes: Vertex[];
  statuses: VertexStatus[];
  logs: VertexLog[];
  warnings: VertexWarning[];
}

export interface Vertex {
  digest: string;
  inputs: string[];
  name: string;
  cached: boolean;
  started: Date | undefined;
  completed:
    | Date
    | undefined;
  /** typed errors? */
  error: string;
  progressGroup: ProgressGroup | undefined;
}

export interface VertexStatus {
  ID: string;
  vertex: string;
  name: string;
  current: number;
  total: number;
  timestamp: Date | undefined;
  started: Date | undefined;
  completed: Date | undefined;
}

export interface VertexLog {
  vertex: string;
  timestamp: Date | undefined;
  stream: number;
  msg: Uint8Array;
}

export interface VertexWarning {
  vertex: string;
  level: number;
  short: Uint8Array;
  detail: Uint8Array[];
  url: string;
  info: SourceInfo | undefined;
  ranges: Range[];
}

export interface BytesMessage {
  data: Uint8Array;
}

export interface ListWorkersRequest {
  /** containerd style */
  filter: string[];
}

export interface ListWorkersResponse {
  record: WorkerRecord[];
}

export interface InfoRequest {
}

export interface InfoResponse {
  buildkitVersion: BuildkitVersion | undefined;
}

export interface BuildHistoryRequest {
  ActiveOnly: boolean;
  Ref: string;
  EarlyExit: boolean;
}

export interface BuildHistoryEvent {
  type: BuildHistoryEventType;
  record: BuildHistoryRecord | undefined;
}

export interface BuildHistoryRecord {
  Ref: string;
  Frontend: string;
  FrontendAttrs: { [key: string]: string };
  Exporters: Exporter[];
  error: Status | undefined;
  CreatedAt: Date | undefined;
  CompletedAt: Date | undefined;
  logs: Descriptor | undefined;
  ExporterResponse: { [key: string]: string };
  Result: BuildResultInfo | undefined;
  Results: { [key: string]: BuildResultInfo };
  Generation: number;
  trace: Descriptor | undefined;
  pinned: boolean;
  numCachedSteps: number;
  numTotalSteps: number;
  numCompletedSteps: number;
  /**
   * TODO: tags
   * TODO: unclipped logs
   */
  externalError: Descriptor | undefined;
}

export interface BuildHistoryRecord_FrontendAttrsEntry {
  key: string;
  value: string;
}

export interface BuildHistoryRecord_ExporterResponseEntry {
  key: string;
  value: string;
}

export interface BuildHistoryRecord_ResultsEntry {
  key: string;
  value: BuildResultInfo | undefined;
}

export interface UpdateBuildHistoryRequest {
  Ref: string;
  Pinned: boolean;
  Delete: boolean;
  Finalize: boolean;
}

export interface UpdateBuildHistoryResponse {
}

export interface Descriptor {
  mediaType: string;
  digest: string;
  size: number;
  annotations: { [key: string]: string };
}

export interface Descriptor_AnnotationsEntry {
  key: string;
  value: string;
}

export interface BuildResultInfo {
  ResultDeprecated: Descriptor | undefined;
  Attestations: Descriptor[];
  Results: { [key: number]: Descriptor };
}

export interface BuildResultInfo_ResultsEntry {
  key: number;
  value: Descriptor | undefined;
}

/** Exporter describes the output exporter */
export interface Exporter {
  /** Type identifies the exporter */
  Type: string;
  /** Attrs specifies exporter configuration */
  Attrs: { [key: string]: string };
}

export interface Exporter_AttrsEntry {
  key: string;
  value: string;
}

function createBasePruneRequest(): PruneRequest {
  return { filter: [], all: false, keepDuration: 0, keepBytes: 0 };
}

export const PruneRequest = {
  encode(message: PruneRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.filter) {
      writer.uint32(10).string(v!);
    }
    if (message.all !== false) {
      writer.uint32(16).bool(message.all);
    }
    if (message.keepDuration !== 0) {
      writer.uint32(24).int64(message.keepDuration);
    }
    if (message.keepBytes !== 0) {
      writer.uint32(32).int64(message.keepBytes);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PruneRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePruneRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.filter.push(reader.string());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.all = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.keepDuration = longToNumber(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.keepBytes = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PruneRequest {
    return {
      filter: globalThis.Array.isArray(object?.filter) ? object.filter.map((e: any) => globalThis.String(e)) : [],
      all: isSet(object.all) ? globalThis.Boolean(object.all) : false,
      keepDuration: isSet(object.keepDuration) ? globalThis.Number(object.keepDuration) : 0,
      keepBytes: isSet(object.keepBytes) ? globalThis.Number(object.keepBytes) : 0,
    };
  },

  toJSON(message: PruneRequest): unknown {
    const obj: any = {};
    if (message.filter?.length) {
      obj.filter = message.filter;
    }
    if (message.all !== false) {
      obj.all = message.all;
    }
    if (message.keepDuration !== 0) {
      obj.keepDuration = Math.round(message.keepDuration);
    }
    if (message.keepBytes !== 0) {
      obj.keepBytes = Math.round(message.keepBytes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PruneRequest>, I>>(base?: I): PruneRequest {
    return PruneRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PruneRequest>, I>>(object: I): PruneRequest {
    const message = createBasePruneRequest();
    message.filter = object.filter?.map((e) => e) || [];
    message.all = object.all ?? false;
    message.keepDuration = object.keepDuration ?? 0;
    message.keepBytes = object.keepBytes ?? 0;
    return message;
  },
};

function createBaseDiskUsageRequest(): DiskUsageRequest {
  return { filter: [] };
}

export const DiskUsageRequest = {
  encode(message: DiskUsageRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.filter) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DiskUsageRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiskUsageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.filter.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiskUsageRequest {
    return {
      filter: globalThis.Array.isArray(object?.filter) ? object.filter.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: DiskUsageRequest): unknown {
    const obj: any = {};
    if (message.filter?.length) {
      obj.filter = message.filter;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DiskUsageRequest>, I>>(base?: I): DiskUsageRequest {
    return DiskUsageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DiskUsageRequest>, I>>(object: I): DiskUsageRequest {
    const message = createBaseDiskUsageRequest();
    message.filter = object.filter?.map((e) => e) || [];
    return message;
  },
};

function createBaseDiskUsageResponse(): DiskUsageResponse {
  return { record: [] };
}

export const DiskUsageResponse = {
  encode(message: DiskUsageResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.record) {
      UsageRecord.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DiskUsageResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiskUsageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.record.push(UsageRecord.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiskUsageResponse {
    return {
      record: globalThis.Array.isArray(object?.record) ? object.record.map((e: any) => UsageRecord.fromJSON(e)) : [],
    };
  },

  toJSON(message: DiskUsageResponse): unknown {
    const obj: any = {};
    if (message.record?.length) {
      obj.record = message.record.map((e) => UsageRecord.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DiskUsageResponse>, I>>(base?: I): DiskUsageResponse {
    return DiskUsageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DiskUsageResponse>, I>>(object: I): DiskUsageResponse {
    const message = createBaseDiskUsageResponse();
    message.record = object.record?.map((e) => UsageRecord.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUsageRecord(): UsageRecord {
  return {
    ID: "",
    Mutable: false,
    InUse: false,
    Size: 0,
    Parent: "",
    CreatedAt: undefined,
    LastUsedAt: undefined,
    UsageCount: 0,
    Description: "",
    RecordType: "",
    Shared: false,
    Parents: [],
  };
}

export const UsageRecord = {
  encode(message: UsageRecord, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ID !== "") {
      writer.uint32(10).string(message.ID);
    }
    if (message.Mutable !== false) {
      writer.uint32(16).bool(message.Mutable);
    }
    if (message.InUse !== false) {
      writer.uint32(24).bool(message.InUse);
    }
    if (message.Size !== 0) {
      writer.uint32(32).int64(message.Size);
    }
    if (message.Parent !== "") {
      writer.uint32(42).string(message.Parent);
    }
    if (message.CreatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.CreatedAt), writer.uint32(50).fork()).ldelim();
    }
    if (message.LastUsedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.LastUsedAt), writer.uint32(58).fork()).ldelim();
    }
    if (message.UsageCount !== 0) {
      writer.uint32(64).int64(message.UsageCount);
    }
    if (message.Description !== "") {
      writer.uint32(74).string(message.Description);
    }
    if (message.RecordType !== "") {
      writer.uint32(82).string(message.RecordType);
    }
    if (message.Shared !== false) {
      writer.uint32(88).bool(message.Shared);
    }
    for (const v of message.Parents) {
      writer.uint32(98).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UsageRecord {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUsageRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ID = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.Mutable = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.InUse = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.Size = longToNumber(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.Parent = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.CreatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.LastUsedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.UsageCount = longToNumber(reader.int64() as Long);
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.Description = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.RecordType = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.Shared = reader.bool();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.Parents.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UsageRecord {
    return {
      ID: isSet(object.ID) ? globalThis.String(object.ID) : "",
      Mutable: isSet(object.Mutable) ? globalThis.Boolean(object.Mutable) : false,
      InUse: isSet(object.InUse) ? globalThis.Boolean(object.InUse) : false,
      Size: isSet(object.Size) ? globalThis.Number(object.Size) : 0,
      Parent: isSet(object.Parent) ? globalThis.String(object.Parent) : "",
      CreatedAt: isSet(object.CreatedAt) ? fromJsonTimestamp(object.CreatedAt) : undefined,
      LastUsedAt: isSet(object.LastUsedAt) ? fromJsonTimestamp(object.LastUsedAt) : undefined,
      UsageCount: isSet(object.UsageCount) ? globalThis.Number(object.UsageCount) : 0,
      Description: isSet(object.Description) ? globalThis.String(object.Description) : "",
      RecordType: isSet(object.RecordType) ? globalThis.String(object.RecordType) : "",
      Shared: isSet(object.Shared) ? globalThis.Boolean(object.Shared) : false,
      Parents: globalThis.Array.isArray(object?.Parents) ? object.Parents.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: UsageRecord): unknown {
    const obj: any = {};
    if (message.ID !== "") {
      obj.ID = message.ID;
    }
    if (message.Mutable !== false) {
      obj.Mutable = message.Mutable;
    }
    if (message.InUse !== false) {
      obj.InUse = message.InUse;
    }
    if (message.Size !== 0) {
      obj.Size = Math.round(message.Size);
    }
    if (message.Parent !== "") {
      obj.Parent = message.Parent;
    }
    if (message.CreatedAt !== undefined) {
      obj.CreatedAt = message.CreatedAt.toISOString();
    }
    if (message.LastUsedAt !== undefined) {
      obj.LastUsedAt = message.LastUsedAt.toISOString();
    }
    if (message.UsageCount !== 0) {
      obj.UsageCount = Math.round(message.UsageCount);
    }
    if (message.Description !== "") {
      obj.Description = message.Description;
    }
    if (message.RecordType !== "") {
      obj.RecordType = message.RecordType;
    }
    if (message.Shared !== false) {
      obj.Shared = message.Shared;
    }
    if (message.Parents?.length) {
      obj.Parents = message.Parents;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UsageRecord>, I>>(base?: I): UsageRecord {
    return UsageRecord.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UsageRecord>, I>>(object: I): UsageRecord {
    const message = createBaseUsageRecord();
    message.ID = object.ID ?? "";
    message.Mutable = object.Mutable ?? false;
    message.InUse = object.InUse ?? false;
    message.Size = object.Size ?? 0;
    message.Parent = object.Parent ?? "";
    message.CreatedAt = object.CreatedAt ?? undefined;
    message.LastUsedAt = object.LastUsedAt ?? undefined;
    message.UsageCount = object.UsageCount ?? 0;
    message.Description = object.Description ?? "";
    message.RecordType = object.RecordType ?? "";
    message.Shared = object.Shared ?? false;
    message.Parents = object.Parents?.map((e) => e) || [];
    return message;
  },
};

function createBaseSolveRequest(): SolveRequest {
  return {
    Ref: "",
    Definition: undefined,
    ExporterDeprecated: "",
    ExporterAttrsDeprecated: {},
    Session: "",
    Frontend: "",
    FrontendAttrs: {},
    Cache: undefined,
    Entitlements: [],
    FrontendInputs: {},
    Internal: false,
    SourcePolicy: undefined,
    Exporters: [],
  };
}

export const SolveRequest = {
  encode(message: SolveRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Ref !== "") {
      writer.uint32(10).string(message.Ref);
    }
    if (message.Definition !== undefined) {
      Definition.encode(message.Definition, writer.uint32(18).fork()).ldelim();
    }
    if (message.ExporterDeprecated !== "") {
      writer.uint32(26).string(message.ExporterDeprecated);
    }
    Object.entries(message.ExporterAttrsDeprecated).forEach(([key, value]) => {
      SolveRequest_ExporterAttrsDeprecatedEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).ldelim();
    });
    if (message.Session !== "") {
      writer.uint32(42).string(message.Session);
    }
    if (message.Frontend !== "") {
      writer.uint32(50).string(message.Frontend);
    }
    Object.entries(message.FrontendAttrs).forEach(([key, value]) => {
      SolveRequest_FrontendAttrsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).ldelim();
    });
    if (message.Cache !== undefined) {
      CacheOptions.encode(message.Cache, writer.uint32(66).fork()).ldelim();
    }
    for (const v of message.Entitlements) {
      writer.uint32(74).string(v!);
    }
    Object.entries(message.FrontendInputs).forEach(([key, value]) => {
      SolveRequest_FrontendInputsEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).ldelim();
    });
    if (message.Internal !== false) {
      writer.uint32(88).bool(message.Internal);
    }
    if (message.SourcePolicy !== undefined) {
      Policy.encode(message.SourcePolicy, writer.uint32(98).fork()).ldelim();
    }
    for (const v of message.Exporters) {
      Exporter.encode(v!, writer.uint32(106).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SolveRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSolveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Ref = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.Definition = Definition.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ExporterDeprecated = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = SolveRequest_ExporterAttrsDeprecatedEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.ExporterAttrsDeprecated[entry4.key] = entry4.value;
          }
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.Session = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.Frontend = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = SolveRequest_FrontendAttrsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.FrontendAttrs[entry7.key] = entry7.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.Cache = CacheOptions.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.Entitlements.push(reader.string());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          const entry10 = SolveRequest_FrontendInputsEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.FrontendInputs[entry10.key] = entry10.value;
          }
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.Internal = reader.bool();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.SourcePolicy = Policy.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.Exporters.push(Exporter.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SolveRequest {
    return {
      Ref: isSet(object.Ref) ? globalThis.String(object.Ref) : "",
      Definition: isSet(object.Definition) ? Definition.fromJSON(object.Definition) : undefined,
      ExporterDeprecated: isSet(object.ExporterDeprecated) ? globalThis.String(object.ExporterDeprecated) : "",
      ExporterAttrsDeprecated: isObject(object.ExporterAttrsDeprecated)
        ? Object.entries(object.ExporterAttrsDeprecated).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      Session: isSet(object.Session) ? globalThis.String(object.Session) : "",
      Frontend: isSet(object.Frontend) ? globalThis.String(object.Frontend) : "",
      FrontendAttrs: isObject(object.FrontendAttrs)
        ? Object.entries(object.FrontendAttrs).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      Cache: isSet(object.Cache) ? CacheOptions.fromJSON(object.Cache) : undefined,
      Entitlements: globalThis.Array.isArray(object?.Entitlements)
        ? object.Entitlements.map((e: any) => globalThis.String(e))
        : [],
      FrontendInputs: isObject(object.FrontendInputs)
        ? Object.entries(object.FrontendInputs).reduce<{ [key: string]: Definition }>((acc, [key, value]) => {
          acc[key] = Definition.fromJSON(value);
          return acc;
        }, {})
        : {},
      Internal: isSet(object.Internal) ? globalThis.Boolean(object.Internal) : false,
      SourcePolicy: isSet(object.SourcePolicy) ? Policy.fromJSON(object.SourcePolicy) : undefined,
      Exporters: globalThis.Array.isArray(object?.Exporters)
        ? object.Exporters.map((e: any) => Exporter.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SolveRequest): unknown {
    const obj: any = {};
    if (message.Ref !== "") {
      obj.Ref = message.Ref;
    }
    if (message.Definition !== undefined) {
      obj.Definition = Definition.toJSON(message.Definition);
    }
    if (message.ExporterDeprecated !== "") {
      obj.ExporterDeprecated = message.ExporterDeprecated;
    }
    if (message.ExporterAttrsDeprecated) {
      const entries = Object.entries(message.ExporterAttrsDeprecated);
      if (entries.length > 0) {
        obj.ExporterAttrsDeprecated = {};
        entries.forEach(([k, v]) => {
          obj.ExporterAttrsDeprecated[k] = v;
        });
      }
    }
    if (message.Session !== "") {
      obj.Session = message.Session;
    }
    if (message.Frontend !== "") {
      obj.Frontend = message.Frontend;
    }
    if (message.FrontendAttrs) {
      const entries = Object.entries(message.FrontendAttrs);
      if (entries.length > 0) {
        obj.FrontendAttrs = {};
        entries.forEach(([k, v]) => {
          obj.FrontendAttrs[k] = v;
        });
      }
    }
    if (message.Cache !== undefined) {
      obj.Cache = CacheOptions.toJSON(message.Cache);
    }
    if (message.Entitlements?.length) {
      obj.Entitlements = message.Entitlements;
    }
    if (message.FrontendInputs) {
      const entries = Object.entries(message.FrontendInputs);
      if (entries.length > 0) {
        obj.FrontendInputs = {};
        entries.forEach(([k, v]) => {
          obj.FrontendInputs[k] = Definition.toJSON(v);
        });
      }
    }
    if (message.Internal !== false) {
      obj.Internal = message.Internal;
    }
    if (message.SourcePolicy !== undefined) {
      obj.SourcePolicy = Policy.toJSON(message.SourcePolicy);
    }
    if (message.Exporters?.length) {
      obj.Exporters = message.Exporters.map((e) => Exporter.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SolveRequest>, I>>(base?: I): SolveRequest {
    return SolveRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SolveRequest>, I>>(object: I): SolveRequest {
    const message = createBaseSolveRequest();
    message.Ref = object.Ref ?? "";
    message.Definition = (object.Definition !== undefined && object.Definition !== null)
      ? Definition.fromPartial(object.Definition)
      : undefined;
    message.ExporterDeprecated = object.ExporterDeprecated ?? "";
    message.ExporterAttrsDeprecated = Object.entries(object.ExporterAttrsDeprecated ?? {}).reduce<
      { [key: string]: string }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.Session = object.Session ?? "";
    message.Frontend = object.Frontend ?? "";
    message.FrontendAttrs = Object.entries(object.FrontendAttrs ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.Cache = (object.Cache !== undefined && object.Cache !== null)
      ? CacheOptions.fromPartial(object.Cache)
      : undefined;
    message.Entitlements = object.Entitlements?.map((e) => e) || [];
    message.FrontendInputs = Object.entries(object.FrontendInputs ?? {}).reduce<{ [key: string]: Definition }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = Definition.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.Internal = object.Internal ?? false;
    message.SourcePolicy = (object.SourcePolicy !== undefined && object.SourcePolicy !== null)
      ? Policy.fromPartial(object.SourcePolicy)
      : undefined;
    message.Exporters = object.Exporters?.map((e) => Exporter.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSolveRequest_ExporterAttrsDeprecatedEntry(): SolveRequest_ExporterAttrsDeprecatedEntry {
  return { key: "", value: "" };
}

export const SolveRequest_ExporterAttrsDeprecatedEntry = {
  encode(message: SolveRequest_ExporterAttrsDeprecatedEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SolveRequest_ExporterAttrsDeprecatedEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSolveRequest_ExporterAttrsDeprecatedEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SolveRequest_ExporterAttrsDeprecatedEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SolveRequest_ExporterAttrsDeprecatedEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SolveRequest_ExporterAttrsDeprecatedEntry>, I>>(
    base?: I,
  ): SolveRequest_ExporterAttrsDeprecatedEntry {
    return SolveRequest_ExporterAttrsDeprecatedEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SolveRequest_ExporterAttrsDeprecatedEntry>, I>>(
    object: I,
  ): SolveRequest_ExporterAttrsDeprecatedEntry {
    const message = createBaseSolveRequest_ExporterAttrsDeprecatedEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSolveRequest_FrontendAttrsEntry(): SolveRequest_FrontendAttrsEntry {
  return { key: "", value: "" };
}

export const SolveRequest_FrontendAttrsEntry = {
  encode(message: SolveRequest_FrontendAttrsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SolveRequest_FrontendAttrsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSolveRequest_FrontendAttrsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SolveRequest_FrontendAttrsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SolveRequest_FrontendAttrsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SolveRequest_FrontendAttrsEntry>, I>>(base?: I): SolveRequest_FrontendAttrsEntry {
    return SolveRequest_FrontendAttrsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SolveRequest_FrontendAttrsEntry>, I>>(
    object: I,
  ): SolveRequest_FrontendAttrsEntry {
    const message = createBaseSolveRequest_FrontendAttrsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSolveRequest_FrontendInputsEntry(): SolveRequest_FrontendInputsEntry {
  return { key: "", value: undefined };
}

export const SolveRequest_FrontendInputsEntry = {
  encode(message: SolveRequest_FrontendInputsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Definition.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SolveRequest_FrontendInputsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSolveRequest_FrontendInputsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Definition.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SolveRequest_FrontendInputsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Definition.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: SolveRequest_FrontendInputsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Definition.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SolveRequest_FrontendInputsEntry>, I>>(
    base?: I,
  ): SolveRequest_FrontendInputsEntry {
    return SolveRequest_FrontendInputsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SolveRequest_FrontendInputsEntry>, I>>(
    object: I,
  ): SolveRequest_FrontendInputsEntry {
    const message = createBaseSolveRequest_FrontendInputsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Definition.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseCacheOptions(): CacheOptions {
  return { ExportRefDeprecated: "", ImportRefsDeprecated: [], ExportAttrsDeprecated: {}, Exports: [], Imports: [] };
}

export const CacheOptions = {
  encode(message: CacheOptions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ExportRefDeprecated !== "") {
      writer.uint32(10).string(message.ExportRefDeprecated);
    }
    for (const v of message.ImportRefsDeprecated) {
      writer.uint32(18).string(v!);
    }
    Object.entries(message.ExportAttrsDeprecated).forEach(([key, value]) => {
      CacheOptions_ExportAttrsDeprecatedEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    for (const v of message.Exports) {
      CacheOptionsEntry.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.Imports) {
      CacheOptionsEntry.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CacheOptions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCacheOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ExportRefDeprecated = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ImportRefsDeprecated.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = CacheOptions_ExportAttrsDeprecatedEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.ExportAttrsDeprecated[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.Exports.push(CacheOptionsEntry.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.Imports.push(CacheOptionsEntry.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CacheOptions {
    return {
      ExportRefDeprecated: isSet(object.ExportRefDeprecated) ? globalThis.String(object.ExportRefDeprecated) : "",
      ImportRefsDeprecated: globalThis.Array.isArray(object?.ImportRefsDeprecated)
        ? object.ImportRefsDeprecated.map((e: any) => globalThis.String(e))
        : [],
      ExportAttrsDeprecated: isObject(object.ExportAttrsDeprecated)
        ? Object.entries(object.ExportAttrsDeprecated).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      Exports: globalThis.Array.isArray(object?.Exports)
        ? object.Exports.map((e: any) => CacheOptionsEntry.fromJSON(e))
        : [],
      Imports: globalThis.Array.isArray(object?.Imports)
        ? object.Imports.map((e: any) => CacheOptionsEntry.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CacheOptions): unknown {
    const obj: any = {};
    if (message.ExportRefDeprecated !== "") {
      obj.ExportRefDeprecated = message.ExportRefDeprecated;
    }
    if (message.ImportRefsDeprecated?.length) {
      obj.ImportRefsDeprecated = message.ImportRefsDeprecated;
    }
    if (message.ExportAttrsDeprecated) {
      const entries = Object.entries(message.ExportAttrsDeprecated);
      if (entries.length > 0) {
        obj.ExportAttrsDeprecated = {};
        entries.forEach(([k, v]) => {
          obj.ExportAttrsDeprecated[k] = v;
        });
      }
    }
    if (message.Exports?.length) {
      obj.Exports = message.Exports.map((e) => CacheOptionsEntry.toJSON(e));
    }
    if (message.Imports?.length) {
      obj.Imports = message.Imports.map((e) => CacheOptionsEntry.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CacheOptions>, I>>(base?: I): CacheOptions {
    return CacheOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CacheOptions>, I>>(object: I): CacheOptions {
    const message = createBaseCacheOptions();
    message.ExportRefDeprecated = object.ExportRefDeprecated ?? "";
    message.ImportRefsDeprecated = object.ImportRefsDeprecated?.map((e) => e) || [];
    message.ExportAttrsDeprecated = Object.entries(object.ExportAttrsDeprecated ?? {}).reduce<
      { [key: string]: string }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.Exports = object.Exports?.map((e) => CacheOptionsEntry.fromPartial(e)) || [];
    message.Imports = object.Imports?.map((e) => CacheOptionsEntry.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCacheOptions_ExportAttrsDeprecatedEntry(): CacheOptions_ExportAttrsDeprecatedEntry {
  return { key: "", value: "" };
}

export const CacheOptions_ExportAttrsDeprecatedEntry = {
  encode(message: CacheOptions_ExportAttrsDeprecatedEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CacheOptions_ExportAttrsDeprecatedEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCacheOptions_ExportAttrsDeprecatedEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CacheOptions_ExportAttrsDeprecatedEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CacheOptions_ExportAttrsDeprecatedEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CacheOptions_ExportAttrsDeprecatedEntry>, I>>(
    base?: I,
  ): CacheOptions_ExportAttrsDeprecatedEntry {
    return CacheOptions_ExportAttrsDeprecatedEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CacheOptions_ExportAttrsDeprecatedEntry>, I>>(
    object: I,
  ): CacheOptions_ExportAttrsDeprecatedEntry {
    const message = createBaseCacheOptions_ExportAttrsDeprecatedEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCacheOptionsEntry(): CacheOptionsEntry {
  return { Type: "", Attrs: {} };
}

export const CacheOptionsEntry = {
  encode(message: CacheOptionsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Type !== "") {
      writer.uint32(10).string(message.Type);
    }
    Object.entries(message.Attrs).forEach(([key, value]) => {
      CacheOptionsEntry_AttrsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CacheOptionsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCacheOptionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Type = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = CacheOptionsEntry_AttrsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.Attrs[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CacheOptionsEntry {
    return {
      Type: isSet(object.Type) ? globalThis.String(object.Type) : "",
      Attrs: isObject(object.Attrs)
        ? Object.entries(object.Attrs).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: CacheOptionsEntry): unknown {
    const obj: any = {};
    if (message.Type !== "") {
      obj.Type = message.Type;
    }
    if (message.Attrs) {
      const entries = Object.entries(message.Attrs);
      if (entries.length > 0) {
        obj.Attrs = {};
        entries.forEach(([k, v]) => {
          obj.Attrs[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CacheOptionsEntry>, I>>(base?: I): CacheOptionsEntry {
    return CacheOptionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CacheOptionsEntry>, I>>(object: I): CacheOptionsEntry {
    const message = createBaseCacheOptionsEntry();
    message.Type = object.Type ?? "";
    message.Attrs = Object.entries(object.Attrs ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseCacheOptionsEntry_AttrsEntry(): CacheOptionsEntry_AttrsEntry {
  return { key: "", value: "" };
}

export const CacheOptionsEntry_AttrsEntry = {
  encode(message: CacheOptionsEntry_AttrsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CacheOptionsEntry_AttrsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCacheOptionsEntry_AttrsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CacheOptionsEntry_AttrsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CacheOptionsEntry_AttrsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CacheOptionsEntry_AttrsEntry>, I>>(base?: I): CacheOptionsEntry_AttrsEntry {
    return CacheOptionsEntry_AttrsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CacheOptionsEntry_AttrsEntry>, I>>(object: I): CacheOptionsEntry_AttrsEntry {
    const message = createBaseCacheOptionsEntry_AttrsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSolveResponse(): SolveResponse {
  return { ExporterResponse: {} };
}

export const SolveResponse = {
  encode(message: SolveResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    Object.entries(message.ExporterResponse).forEach(([key, value]) => {
      SolveResponse_ExporterResponseEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SolveResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSolveResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = SolveResponse_ExporterResponseEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.ExporterResponse[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SolveResponse {
    return {
      ExporterResponse: isObject(object.ExporterResponse)
        ? Object.entries(object.ExporterResponse).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SolveResponse): unknown {
    const obj: any = {};
    if (message.ExporterResponse) {
      const entries = Object.entries(message.ExporterResponse);
      if (entries.length > 0) {
        obj.ExporterResponse = {};
        entries.forEach(([k, v]) => {
          obj.ExporterResponse[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SolveResponse>, I>>(base?: I): SolveResponse {
    return SolveResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SolveResponse>, I>>(object: I): SolveResponse {
    const message = createBaseSolveResponse();
    message.ExporterResponse = Object.entries(object.ExporterResponse ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseSolveResponse_ExporterResponseEntry(): SolveResponse_ExporterResponseEntry {
  return { key: "", value: "" };
}

export const SolveResponse_ExporterResponseEntry = {
  encode(message: SolveResponse_ExporterResponseEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SolveResponse_ExporterResponseEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSolveResponse_ExporterResponseEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SolveResponse_ExporterResponseEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SolveResponse_ExporterResponseEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SolveResponse_ExporterResponseEntry>, I>>(
    base?: I,
  ): SolveResponse_ExporterResponseEntry {
    return SolveResponse_ExporterResponseEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SolveResponse_ExporterResponseEntry>, I>>(
    object: I,
  ): SolveResponse_ExporterResponseEntry {
    const message = createBaseSolveResponse_ExporterResponseEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStatusRequest(): StatusRequest {
  return { Ref: "" };
}

export const StatusRequest = {
  encode(message: StatusRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Ref !== "") {
      writer.uint32(10).string(message.Ref);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StatusRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Ref = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatusRequest {
    return { Ref: isSet(object.Ref) ? globalThis.String(object.Ref) : "" };
  },

  toJSON(message: StatusRequest): unknown {
    const obj: any = {};
    if (message.Ref !== "") {
      obj.Ref = message.Ref;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StatusRequest>, I>>(base?: I): StatusRequest {
    return StatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StatusRequest>, I>>(object: I): StatusRequest {
    const message = createBaseStatusRequest();
    message.Ref = object.Ref ?? "";
    return message;
  },
};

function createBaseStatusResponse(): StatusResponse {
  return { vertexes: [], statuses: [], logs: [], warnings: [] };
}

export const StatusResponse = {
  encode(message: StatusResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.vertexes) {
      Vertex.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.statuses) {
      VertexStatus.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    for (const v of message.logs) {
      VertexLog.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    for (const v of message.warnings) {
      VertexWarning.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StatusResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.vertexes.push(Vertex.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.statuses.push(VertexStatus.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.logs.push(VertexLog.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.warnings.push(VertexWarning.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatusResponse {
    return {
      vertexes: globalThis.Array.isArray(object?.vertexes) ? object.vertexes.map((e: any) => Vertex.fromJSON(e)) : [],
      statuses: globalThis.Array.isArray(object?.statuses)
        ? object.statuses.map((e: any) => VertexStatus.fromJSON(e))
        : [],
      logs: globalThis.Array.isArray(object?.logs) ? object.logs.map((e: any) => VertexLog.fromJSON(e)) : [],
      warnings: globalThis.Array.isArray(object?.warnings)
        ? object.warnings.map((e: any) => VertexWarning.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StatusResponse): unknown {
    const obj: any = {};
    if (message.vertexes?.length) {
      obj.vertexes = message.vertexes.map((e) => Vertex.toJSON(e));
    }
    if (message.statuses?.length) {
      obj.statuses = message.statuses.map((e) => VertexStatus.toJSON(e));
    }
    if (message.logs?.length) {
      obj.logs = message.logs.map((e) => VertexLog.toJSON(e));
    }
    if (message.warnings?.length) {
      obj.warnings = message.warnings.map((e) => VertexWarning.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StatusResponse>, I>>(base?: I): StatusResponse {
    return StatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StatusResponse>, I>>(object: I): StatusResponse {
    const message = createBaseStatusResponse();
    message.vertexes = object.vertexes?.map((e) => Vertex.fromPartial(e)) || [];
    message.statuses = object.statuses?.map((e) => VertexStatus.fromPartial(e)) || [];
    message.logs = object.logs?.map((e) => VertexLog.fromPartial(e)) || [];
    message.warnings = object.warnings?.map((e) => VertexWarning.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVertex(): Vertex {
  return {
    digest: "",
    inputs: [],
    name: "",
    cached: false,
    started: undefined,
    completed: undefined,
    error: "",
    progressGroup: undefined,
  };
}

export const Vertex = {
  encode(message: Vertex, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.digest !== "") {
      writer.uint32(10).string(message.digest);
    }
    for (const v of message.inputs) {
      writer.uint32(18).string(v!);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.cached !== false) {
      writer.uint32(32).bool(message.cached);
    }
    if (message.started !== undefined) {
      Timestamp.encode(toTimestamp(message.started), writer.uint32(42).fork()).ldelim();
    }
    if (message.completed !== undefined) {
      Timestamp.encode(toTimestamp(message.completed), writer.uint32(50).fork()).ldelim();
    }
    if (message.error !== "") {
      writer.uint32(58).string(message.error);
    }
    if (message.progressGroup !== undefined) {
      ProgressGroup.encode(message.progressGroup, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Vertex {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVertex();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.digest = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.inputs.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.cached = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.started = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.completed = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.error = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.progressGroup = ProgressGroup.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Vertex {
    return {
      digest: isSet(object.digest) ? globalThis.String(object.digest) : "",
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e: any) => globalThis.String(e)) : [],
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      cached: isSet(object.cached) ? globalThis.Boolean(object.cached) : false,
      started: isSet(object.started) ? fromJsonTimestamp(object.started) : undefined,
      completed: isSet(object.completed) ? fromJsonTimestamp(object.completed) : undefined,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      progressGroup: isSet(object.progressGroup) ? ProgressGroup.fromJSON(object.progressGroup) : undefined,
    };
  },

  toJSON(message: Vertex): unknown {
    const obj: any = {};
    if (message.digest !== "") {
      obj.digest = message.digest;
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.cached !== false) {
      obj.cached = message.cached;
    }
    if (message.started !== undefined) {
      obj.started = message.started.toISOString();
    }
    if (message.completed !== undefined) {
      obj.completed = message.completed.toISOString();
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.progressGroup !== undefined) {
      obj.progressGroup = ProgressGroup.toJSON(message.progressGroup);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Vertex>, I>>(base?: I): Vertex {
    return Vertex.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Vertex>, I>>(object: I): Vertex {
    const message = createBaseVertex();
    message.digest = object.digest ?? "";
    message.inputs = object.inputs?.map((e) => e) || [];
    message.name = object.name ?? "";
    message.cached = object.cached ?? false;
    message.started = object.started ?? undefined;
    message.completed = object.completed ?? undefined;
    message.error = object.error ?? "";
    message.progressGroup = (object.progressGroup !== undefined && object.progressGroup !== null)
      ? ProgressGroup.fromPartial(object.progressGroup)
      : undefined;
    return message;
  },
};

function createBaseVertexStatus(): VertexStatus {
  return {
    ID: "",
    vertex: "",
    name: "",
    current: 0,
    total: 0,
    timestamp: undefined,
    started: undefined,
    completed: undefined,
  };
}

export const VertexStatus = {
  encode(message: VertexStatus, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ID !== "") {
      writer.uint32(10).string(message.ID);
    }
    if (message.vertex !== "") {
      writer.uint32(18).string(message.vertex);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.current !== 0) {
      writer.uint32(32).int64(message.current);
    }
    if (message.total !== 0) {
      writer.uint32(40).int64(message.total);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(50).fork()).ldelim();
    }
    if (message.started !== undefined) {
      Timestamp.encode(toTimestamp(message.started), writer.uint32(58).fork()).ldelim();
    }
    if (message.completed !== undefined) {
      Timestamp.encode(toTimestamp(message.completed), writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VertexStatus {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVertexStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ID = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.vertex = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.current = longToNumber(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.total = longToNumber(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.started = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.completed = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VertexStatus {
    return {
      ID: isSet(object.ID) ? globalThis.String(object.ID) : "",
      vertex: isSet(object.vertex) ? globalThis.String(object.vertex) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      current: isSet(object.current) ? globalThis.Number(object.current) : 0,
      total: isSet(object.total) ? globalThis.Number(object.total) : 0,
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      started: isSet(object.started) ? fromJsonTimestamp(object.started) : undefined,
      completed: isSet(object.completed) ? fromJsonTimestamp(object.completed) : undefined,
    };
  },

  toJSON(message: VertexStatus): unknown {
    const obj: any = {};
    if (message.ID !== "") {
      obj.ID = message.ID;
    }
    if (message.vertex !== "") {
      obj.vertex = message.vertex;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.current !== 0) {
      obj.current = Math.round(message.current);
    }
    if (message.total !== 0) {
      obj.total = Math.round(message.total);
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.started !== undefined) {
      obj.started = message.started.toISOString();
    }
    if (message.completed !== undefined) {
      obj.completed = message.completed.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VertexStatus>, I>>(base?: I): VertexStatus {
    return VertexStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VertexStatus>, I>>(object: I): VertexStatus {
    const message = createBaseVertexStatus();
    message.ID = object.ID ?? "";
    message.vertex = object.vertex ?? "";
    message.name = object.name ?? "";
    message.current = object.current ?? 0;
    message.total = object.total ?? 0;
    message.timestamp = object.timestamp ?? undefined;
    message.started = object.started ?? undefined;
    message.completed = object.completed ?? undefined;
    return message;
  },
};

function createBaseVertexLog(): VertexLog {
  return { vertex: "", timestamp: undefined, stream: 0, msg: new Uint8Array(0) };
}

export const VertexLog = {
  encode(message: VertexLog, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.vertex !== "") {
      writer.uint32(10).string(message.vertex);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(18).fork()).ldelim();
    }
    if (message.stream !== 0) {
      writer.uint32(24).int64(message.stream);
    }
    if (message.msg.length !== 0) {
      writer.uint32(34).bytes(message.msg);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VertexLog {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVertexLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.vertex = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.stream = longToNumber(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.msg = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VertexLog {
    return {
      vertex: isSet(object.vertex) ? globalThis.String(object.vertex) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      stream: isSet(object.stream) ? globalThis.Number(object.stream) : 0,
      msg: isSet(object.msg) ? bytesFromBase64(object.msg) : new Uint8Array(0),
    };
  },

  toJSON(message: VertexLog): unknown {
    const obj: any = {};
    if (message.vertex !== "") {
      obj.vertex = message.vertex;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.stream !== 0) {
      obj.stream = Math.round(message.stream);
    }
    if (message.msg.length !== 0) {
      obj.msg = base64FromBytes(message.msg);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VertexLog>, I>>(base?: I): VertexLog {
    return VertexLog.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VertexLog>, I>>(object: I): VertexLog {
    const message = createBaseVertexLog();
    message.vertex = object.vertex ?? "";
    message.timestamp = object.timestamp ?? undefined;
    message.stream = object.stream ?? 0;
    message.msg = object.msg ?? new Uint8Array(0);
    return message;
  },
};

function createBaseVertexWarning(): VertexWarning {
  return { vertex: "", level: 0, short: new Uint8Array(0), detail: [], url: "", info: undefined, ranges: [] };
}

export const VertexWarning = {
  encode(message: VertexWarning, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.vertex !== "") {
      writer.uint32(10).string(message.vertex);
    }
    if (message.level !== 0) {
      writer.uint32(16).int64(message.level);
    }
    if (message.short.length !== 0) {
      writer.uint32(26).bytes(message.short);
    }
    for (const v of message.detail) {
      writer.uint32(34).bytes(v!);
    }
    if (message.url !== "") {
      writer.uint32(42).string(message.url);
    }
    if (message.info !== undefined) {
      SourceInfo.encode(message.info, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.ranges) {
      Range.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VertexWarning {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVertexWarning();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.vertex = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.level = longToNumber(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.short = reader.bytes();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.detail.push(reader.bytes());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.url = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.info = SourceInfo.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.ranges.push(Range.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VertexWarning {
    return {
      vertex: isSet(object.vertex) ? globalThis.String(object.vertex) : "",
      level: isSet(object.level) ? globalThis.Number(object.level) : 0,
      short: isSet(object.short) ? bytesFromBase64(object.short) : new Uint8Array(0),
      detail: globalThis.Array.isArray(object?.detail) ? object.detail.map((e: any) => bytesFromBase64(e)) : [],
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      info: isSet(object.info) ? SourceInfo.fromJSON(object.info) : undefined,
      ranges: globalThis.Array.isArray(object?.ranges) ? object.ranges.map((e: any) => Range.fromJSON(e)) : [],
    };
  },

  toJSON(message: VertexWarning): unknown {
    const obj: any = {};
    if (message.vertex !== "") {
      obj.vertex = message.vertex;
    }
    if (message.level !== 0) {
      obj.level = Math.round(message.level);
    }
    if (message.short.length !== 0) {
      obj.short = base64FromBytes(message.short);
    }
    if (message.detail?.length) {
      obj.detail = message.detail.map((e) => base64FromBytes(e));
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.info !== undefined) {
      obj.info = SourceInfo.toJSON(message.info);
    }
    if (message.ranges?.length) {
      obj.ranges = message.ranges.map((e) => Range.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VertexWarning>, I>>(base?: I): VertexWarning {
    return VertexWarning.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VertexWarning>, I>>(object: I): VertexWarning {
    const message = createBaseVertexWarning();
    message.vertex = object.vertex ?? "";
    message.level = object.level ?? 0;
    message.short = object.short ?? new Uint8Array(0);
    message.detail = object.detail?.map((e) => e) || [];
    message.url = object.url ?? "";
    message.info = (object.info !== undefined && object.info !== null)
      ? SourceInfo.fromPartial(object.info)
      : undefined;
    message.ranges = object.ranges?.map((e) => Range.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBytesMessage(): BytesMessage {
  return { data: new Uint8Array(0) };
}

export const BytesMessage = {
  encode(message: BytesMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BytesMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBytesMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.data = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BytesMessage {
    return { data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0) };
  },

  toJSON(message: BytesMessage): unknown {
    const obj: any = {};
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BytesMessage>, I>>(base?: I): BytesMessage {
    return BytesMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BytesMessage>, I>>(object: I): BytesMessage {
    const message = createBaseBytesMessage();
    message.data = object.data ?? new Uint8Array(0);
    return message;
  },
};

function createBaseListWorkersRequest(): ListWorkersRequest {
  return { filter: [] };
}

export const ListWorkersRequest = {
  encode(message: ListWorkersRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.filter) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListWorkersRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.filter.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWorkersRequest {
    return {
      filter: globalThis.Array.isArray(object?.filter) ? object.filter.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ListWorkersRequest): unknown {
    const obj: any = {};
    if (message.filter?.length) {
      obj.filter = message.filter;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListWorkersRequest>, I>>(base?: I): ListWorkersRequest {
    return ListWorkersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListWorkersRequest>, I>>(object: I): ListWorkersRequest {
    const message = createBaseListWorkersRequest();
    message.filter = object.filter?.map((e) => e) || [];
    return message;
  },
};

function createBaseListWorkersResponse(): ListWorkersResponse {
  return { record: [] };
}

export const ListWorkersResponse = {
  encode(message: ListWorkersResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.record) {
      WorkerRecord.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListWorkersResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.record.push(WorkerRecord.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWorkersResponse {
    return {
      record: globalThis.Array.isArray(object?.record) ? object.record.map((e: any) => WorkerRecord.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListWorkersResponse): unknown {
    const obj: any = {};
    if (message.record?.length) {
      obj.record = message.record.map((e) => WorkerRecord.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListWorkersResponse>, I>>(base?: I): ListWorkersResponse {
    return ListWorkersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListWorkersResponse>, I>>(object: I): ListWorkersResponse {
    const message = createBaseListWorkersResponse();
    message.record = object.record?.map((e) => WorkerRecord.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInfoRequest(): InfoRequest {
  return {};
}

export const InfoRequest = {
  encode(_: InfoRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InfoRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): InfoRequest {
    return {};
  },

  toJSON(_: InfoRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<InfoRequest>, I>>(base?: I): InfoRequest {
    return InfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InfoRequest>, I>>(_: I): InfoRequest {
    const message = createBaseInfoRequest();
    return message;
  },
};

function createBaseInfoResponse(): InfoResponse {
  return { buildkitVersion: undefined };
}

export const InfoResponse = {
  encode(message: InfoResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.buildkitVersion !== undefined) {
      BuildkitVersion.encode(message.buildkitVersion, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InfoResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.buildkitVersion = BuildkitVersion.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InfoResponse {
    return {
      buildkitVersion: isSet(object.buildkitVersion) ? BuildkitVersion.fromJSON(object.buildkitVersion) : undefined,
    };
  },

  toJSON(message: InfoResponse): unknown {
    const obj: any = {};
    if (message.buildkitVersion !== undefined) {
      obj.buildkitVersion = BuildkitVersion.toJSON(message.buildkitVersion);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InfoResponse>, I>>(base?: I): InfoResponse {
    return InfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InfoResponse>, I>>(object: I): InfoResponse {
    const message = createBaseInfoResponse();
    message.buildkitVersion = (object.buildkitVersion !== undefined && object.buildkitVersion !== null)
      ? BuildkitVersion.fromPartial(object.buildkitVersion)
      : undefined;
    return message;
  },
};

function createBaseBuildHistoryRequest(): BuildHistoryRequest {
  return { ActiveOnly: false, Ref: "", EarlyExit: false };
}

export const BuildHistoryRequest = {
  encode(message: BuildHistoryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ActiveOnly !== false) {
      writer.uint32(8).bool(message.ActiveOnly);
    }
    if (message.Ref !== "") {
      writer.uint32(18).string(message.Ref);
    }
    if (message.EarlyExit !== false) {
      writer.uint32(24).bool(message.EarlyExit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BuildHistoryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildHistoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.ActiveOnly = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.Ref = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.EarlyExit = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildHistoryRequest {
    return {
      ActiveOnly: isSet(object.ActiveOnly) ? globalThis.Boolean(object.ActiveOnly) : false,
      Ref: isSet(object.Ref) ? globalThis.String(object.Ref) : "",
      EarlyExit: isSet(object.EarlyExit) ? globalThis.Boolean(object.EarlyExit) : false,
    };
  },

  toJSON(message: BuildHistoryRequest): unknown {
    const obj: any = {};
    if (message.ActiveOnly !== false) {
      obj.ActiveOnly = message.ActiveOnly;
    }
    if (message.Ref !== "") {
      obj.Ref = message.Ref;
    }
    if (message.EarlyExit !== false) {
      obj.EarlyExit = message.EarlyExit;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildHistoryRequest>, I>>(base?: I): BuildHistoryRequest {
    return BuildHistoryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildHistoryRequest>, I>>(object: I): BuildHistoryRequest {
    const message = createBaseBuildHistoryRequest();
    message.ActiveOnly = object.ActiveOnly ?? false;
    message.Ref = object.Ref ?? "";
    message.EarlyExit = object.EarlyExit ?? false;
    return message;
  },
};

function createBaseBuildHistoryEvent(): BuildHistoryEvent {
  return { type: 0, record: undefined };
}

export const BuildHistoryEvent = {
  encode(message: BuildHistoryEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.record !== undefined) {
      BuildHistoryRecord.encode(message.record, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BuildHistoryEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildHistoryEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.record = BuildHistoryRecord.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildHistoryEvent {
    return {
      type: isSet(object.type) ? buildHistoryEventTypeFromJSON(object.type) : 0,
      record: isSet(object.record) ? BuildHistoryRecord.fromJSON(object.record) : undefined,
    };
  },

  toJSON(message: BuildHistoryEvent): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = buildHistoryEventTypeToJSON(message.type);
    }
    if (message.record !== undefined) {
      obj.record = BuildHistoryRecord.toJSON(message.record);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildHistoryEvent>, I>>(base?: I): BuildHistoryEvent {
    return BuildHistoryEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildHistoryEvent>, I>>(object: I): BuildHistoryEvent {
    const message = createBaseBuildHistoryEvent();
    message.type = object.type ?? 0;
    message.record = (object.record !== undefined && object.record !== null)
      ? BuildHistoryRecord.fromPartial(object.record)
      : undefined;
    return message;
  },
};

function createBaseBuildHistoryRecord(): BuildHistoryRecord {
  return {
    Ref: "",
    Frontend: "",
    FrontendAttrs: {},
    Exporters: [],
    error: undefined,
    CreatedAt: undefined,
    CompletedAt: undefined,
    logs: undefined,
    ExporterResponse: {},
    Result: undefined,
    Results: {},
    Generation: 0,
    trace: undefined,
    pinned: false,
    numCachedSteps: 0,
    numTotalSteps: 0,
    numCompletedSteps: 0,
    externalError: undefined,
  };
}

export const BuildHistoryRecord = {
  encode(message: BuildHistoryRecord, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Ref !== "") {
      writer.uint32(10).string(message.Ref);
    }
    if (message.Frontend !== "") {
      writer.uint32(18).string(message.Frontend);
    }
    Object.entries(message.FrontendAttrs).forEach(([key, value]) => {
      BuildHistoryRecord_FrontendAttrsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    for (const v of message.Exporters) {
      Exporter.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    if (message.error !== undefined) {
      Status.encode(message.error, writer.uint32(42).fork()).ldelim();
    }
    if (message.CreatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.CreatedAt), writer.uint32(50).fork()).ldelim();
    }
    if (message.CompletedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.CompletedAt), writer.uint32(58).fork()).ldelim();
    }
    if (message.logs !== undefined) {
      Descriptor.encode(message.logs, writer.uint32(66).fork()).ldelim();
    }
    Object.entries(message.ExporterResponse).forEach(([key, value]) => {
      BuildHistoryRecord_ExporterResponseEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).ldelim();
    });
    if (message.Result !== undefined) {
      BuildResultInfo.encode(message.Result, writer.uint32(82).fork()).ldelim();
    }
    Object.entries(message.Results).forEach(([key, value]) => {
      BuildHistoryRecord_ResultsEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).ldelim();
    });
    if (message.Generation !== 0) {
      writer.uint32(96).int32(message.Generation);
    }
    if (message.trace !== undefined) {
      Descriptor.encode(message.trace, writer.uint32(106).fork()).ldelim();
    }
    if (message.pinned !== false) {
      writer.uint32(112).bool(message.pinned);
    }
    if (message.numCachedSteps !== 0) {
      writer.uint32(120).int32(message.numCachedSteps);
    }
    if (message.numTotalSteps !== 0) {
      writer.uint32(128).int32(message.numTotalSteps);
    }
    if (message.numCompletedSteps !== 0) {
      writer.uint32(136).int32(message.numCompletedSteps);
    }
    if (message.externalError !== undefined) {
      Descriptor.encode(message.externalError, writer.uint32(146).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BuildHistoryRecord {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildHistoryRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Ref = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.Frontend = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = BuildHistoryRecord_FrontendAttrsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.FrontendAttrs[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.Exporters.push(Exporter.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.error = Status.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.CreatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.CompletedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.logs = Descriptor.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          const entry9 = BuildHistoryRecord_ExporterResponseEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.ExporterResponse[entry9.key] = entry9.value;
          }
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.Result = BuildResultInfo.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          const entry11 = BuildHistoryRecord_ResultsEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.Results[entry11.key] = entry11.value;
          }
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.Generation = reader.int32();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.trace = Descriptor.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.pinned = reader.bool();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.numCachedSteps = reader.int32();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.numTotalSteps = reader.int32();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.numCompletedSteps = reader.int32();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.externalError = Descriptor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildHistoryRecord {
    return {
      Ref: isSet(object.Ref) ? globalThis.String(object.Ref) : "",
      Frontend: isSet(object.Frontend) ? globalThis.String(object.Frontend) : "",
      FrontendAttrs: isObject(object.FrontendAttrs)
        ? Object.entries(object.FrontendAttrs).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      Exporters: globalThis.Array.isArray(object?.Exporters)
        ? object.Exporters.map((e: any) => Exporter.fromJSON(e))
        : [],
      error: isSet(object.error) ? Status.fromJSON(object.error) : undefined,
      CreatedAt: isSet(object.CreatedAt) ? fromJsonTimestamp(object.CreatedAt) : undefined,
      CompletedAt: isSet(object.CompletedAt) ? fromJsonTimestamp(object.CompletedAt) : undefined,
      logs: isSet(object.logs) ? Descriptor.fromJSON(object.logs) : undefined,
      ExporterResponse: isObject(object.ExporterResponse)
        ? Object.entries(object.ExporterResponse).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      Result: isSet(object.Result) ? BuildResultInfo.fromJSON(object.Result) : undefined,
      Results: isObject(object.Results)
        ? Object.entries(object.Results).reduce<{ [key: string]: BuildResultInfo }>((acc, [key, value]) => {
          acc[key] = BuildResultInfo.fromJSON(value);
          return acc;
        }, {})
        : {},
      Generation: isSet(object.Generation) ? globalThis.Number(object.Generation) : 0,
      trace: isSet(object.trace) ? Descriptor.fromJSON(object.trace) : undefined,
      pinned: isSet(object.pinned) ? globalThis.Boolean(object.pinned) : false,
      numCachedSteps: isSet(object.numCachedSteps) ? globalThis.Number(object.numCachedSteps) : 0,
      numTotalSteps: isSet(object.numTotalSteps) ? globalThis.Number(object.numTotalSteps) : 0,
      numCompletedSteps: isSet(object.numCompletedSteps) ? globalThis.Number(object.numCompletedSteps) : 0,
      externalError: isSet(object.externalError) ? Descriptor.fromJSON(object.externalError) : undefined,
    };
  },

  toJSON(message: BuildHistoryRecord): unknown {
    const obj: any = {};
    if (message.Ref !== "") {
      obj.Ref = message.Ref;
    }
    if (message.Frontend !== "") {
      obj.Frontend = message.Frontend;
    }
    if (message.FrontendAttrs) {
      const entries = Object.entries(message.FrontendAttrs);
      if (entries.length > 0) {
        obj.FrontendAttrs = {};
        entries.forEach(([k, v]) => {
          obj.FrontendAttrs[k] = v;
        });
      }
    }
    if (message.Exporters?.length) {
      obj.Exporters = message.Exporters.map((e) => Exporter.toJSON(e));
    }
    if (message.error !== undefined) {
      obj.error = Status.toJSON(message.error);
    }
    if (message.CreatedAt !== undefined) {
      obj.CreatedAt = message.CreatedAt.toISOString();
    }
    if (message.CompletedAt !== undefined) {
      obj.CompletedAt = message.CompletedAt.toISOString();
    }
    if (message.logs !== undefined) {
      obj.logs = Descriptor.toJSON(message.logs);
    }
    if (message.ExporterResponse) {
      const entries = Object.entries(message.ExporterResponse);
      if (entries.length > 0) {
        obj.ExporterResponse = {};
        entries.forEach(([k, v]) => {
          obj.ExporterResponse[k] = v;
        });
      }
    }
    if (message.Result !== undefined) {
      obj.Result = BuildResultInfo.toJSON(message.Result);
    }
    if (message.Results) {
      const entries = Object.entries(message.Results);
      if (entries.length > 0) {
        obj.Results = {};
        entries.forEach(([k, v]) => {
          obj.Results[k] = BuildResultInfo.toJSON(v);
        });
      }
    }
    if (message.Generation !== 0) {
      obj.Generation = Math.round(message.Generation);
    }
    if (message.trace !== undefined) {
      obj.trace = Descriptor.toJSON(message.trace);
    }
    if (message.pinned !== false) {
      obj.pinned = message.pinned;
    }
    if (message.numCachedSteps !== 0) {
      obj.numCachedSteps = Math.round(message.numCachedSteps);
    }
    if (message.numTotalSteps !== 0) {
      obj.numTotalSteps = Math.round(message.numTotalSteps);
    }
    if (message.numCompletedSteps !== 0) {
      obj.numCompletedSteps = Math.round(message.numCompletedSteps);
    }
    if (message.externalError !== undefined) {
      obj.externalError = Descriptor.toJSON(message.externalError);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildHistoryRecord>, I>>(base?: I): BuildHistoryRecord {
    return BuildHistoryRecord.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildHistoryRecord>, I>>(object: I): BuildHistoryRecord {
    const message = createBaseBuildHistoryRecord();
    message.Ref = object.Ref ?? "";
    message.Frontend = object.Frontend ?? "";
    message.FrontendAttrs = Object.entries(object.FrontendAttrs ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.Exporters = object.Exporters?.map((e) => Exporter.fromPartial(e)) || [];
    message.error = (object.error !== undefined && object.error !== null)
      ? Status.fromPartial(object.error)
      : undefined;
    message.CreatedAt = object.CreatedAt ?? undefined;
    message.CompletedAt = object.CompletedAt ?? undefined;
    message.logs = (object.logs !== undefined && object.logs !== null)
      ? Descriptor.fromPartial(object.logs)
      : undefined;
    message.ExporterResponse = Object.entries(object.ExporterResponse ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.Result = (object.Result !== undefined && object.Result !== null)
      ? BuildResultInfo.fromPartial(object.Result)
      : undefined;
    message.Results = Object.entries(object.Results ?? {}).reduce<{ [key: string]: BuildResultInfo }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = BuildResultInfo.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.Generation = object.Generation ?? 0;
    message.trace = (object.trace !== undefined && object.trace !== null)
      ? Descriptor.fromPartial(object.trace)
      : undefined;
    message.pinned = object.pinned ?? false;
    message.numCachedSteps = object.numCachedSteps ?? 0;
    message.numTotalSteps = object.numTotalSteps ?? 0;
    message.numCompletedSteps = object.numCompletedSteps ?? 0;
    message.externalError = (object.externalError !== undefined && object.externalError !== null)
      ? Descriptor.fromPartial(object.externalError)
      : undefined;
    return message;
  },
};

function createBaseBuildHistoryRecord_FrontendAttrsEntry(): BuildHistoryRecord_FrontendAttrsEntry {
  return { key: "", value: "" };
}

export const BuildHistoryRecord_FrontendAttrsEntry = {
  encode(message: BuildHistoryRecord_FrontendAttrsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BuildHistoryRecord_FrontendAttrsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildHistoryRecord_FrontendAttrsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildHistoryRecord_FrontendAttrsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: BuildHistoryRecord_FrontendAttrsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildHistoryRecord_FrontendAttrsEntry>, I>>(
    base?: I,
  ): BuildHistoryRecord_FrontendAttrsEntry {
    return BuildHistoryRecord_FrontendAttrsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildHistoryRecord_FrontendAttrsEntry>, I>>(
    object: I,
  ): BuildHistoryRecord_FrontendAttrsEntry {
    const message = createBaseBuildHistoryRecord_FrontendAttrsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBuildHistoryRecord_ExporterResponseEntry(): BuildHistoryRecord_ExporterResponseEntry {
  return { key: "", value: "" };
}

export const BuildHistoryRecord_ExporterResponseEntry = {
  encode(message: BuildHistoryRecord_ExporterResponseEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BuildHistoryRecord_ExporterResponseEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildHistoryRecord_ExporterResponseEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildHistoryRecord_ExporterResponseEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: BuildHistoryRecord_ExporterResponseEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildHistoryRecord_ExporterResponseEntry>, I>>(
    base?: I,
  ): BuildHistoryRecord_ExporterResponseEntry {
    return BuildHistoryRecord_ExporterResponseEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildHistoryRecord_ExporterResponseEntry>, I>>(
    object: I,
  ): BuildHistoryRecord_ExporterResponseEntry {
    const message = createBaseBuildHistoryRecord_ExporterResponseEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBuildHistoryRecord_ResultsEntry(): BuildHistoryRecord_ResultsEntry {
  return { key: "", value: undefined };
}

export const BuildHistoryRecord_ResultsEntry = {
  encode(message: BuildHistoryRecord_ResultsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      BuildResultInfo.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BuildHistoryRecord_ResultsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildHistoryRecord_ResultsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = BuildResultInfo.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildHistoryRecord_ResultsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? BuildResultInfo.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: BuildHistoryRecord_ResultsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = BuildResultInfo.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildHistoryRecord_ResultsEntry>, I>>(base?: I): BuildHistoryRecord_ResultsEntry {
    return BuildHistoryRecord_ResultsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildHistoryRecord_ResultsEntry>, I>>(
    object: I,
  ): BuildHistoryRecord_ResultsEntry {
    const message = createBaseBuildHistoryRecord_ResultsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? BuildResultInfo.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseUpdateBuildHistoryRequest(): UpdateBuildHistoryRequest {
  return { Ref: "", Pinned: false, Delete: false, Finalize: false };
}

export const UpdateBuildHistoryRequest = {
  encode(message: UpdateBuildHistoryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Ref !== "") {
      writer.uint32(10).string(message.Ref);
    }
    if (message.Pinned !== false) {
      writer.uint32(16).bool(message.Pinned);
    }
    if (message.Delete !== false) {
      writer.uint32(24).bool(message.Delete);
    }
    if (message.Finalize !== false) {
      writer.uint32(32).bool(message.Finalize);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateBuildHistoryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateBuildHistoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Ref = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.Pinned = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.Delete = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.Finalize = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateBuildHistoryRequest {
    return {
      Ref: isSet(object.Ref) ? globalThis.String(object.Ref) : "",
      Pinned: isSet(object.Pinned) ? globalThis.Boolean(object.Pinned) : false,
      Delete: isSet(object.Delete) ? globalThis.Boolean(object.Delete) : false,
      Finalize: isSet(object.Finalize) ? globalThis.Boolean(object.Finalize) : false,
    };
  },

  toJSON(message: UpdateBuildHistoryRequest): unknown {
    const obj: any = {};
    if (message.Ref !== "") {
      obj.Ref = message.Ref;
    }
    if (message.Pinned !== false) {
      obj.Pinned = message.Pinned;
    }
    if (message.Delete !== false) {
      obj.Delete = message.Delete;
    }
    if (message.Finalize !== false) {
      obj.Finalize = message.Finalize;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateBuildHistoryRequest>, I>>(base?: I): UpdateBuildHistoryRequest {
    return UpdateBuildHistoryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateBuildHistoryRequest>, I>>(object: I): UpdateBuildHistoryRequest {
    const message = createBaseUpdateBuildHistoryRequest();
    message.Ref = object.Ref ?? "";
    message.Pinned = object.Pinned ?? false;
    message.Delete = object.Delete ?? false;
    message.Finalize = object.Finalize ?? false;
    return message;
  },
};

function createBaseUpdateBuildHistoryResponse(): UpdateBuildHistoryResponse {
  return {};
}

export const UpdateBuildHistoryResponse = {
  encode(_: UpdateBuildHistoryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateBuildHistoryResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateBuildHistoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UpdateBuildHistoryResponse {
    return {};
  },

  toJSON(_: UpdateBuildHistoryResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateBuildHistoryResponse>, I>>(base?: I): UpdateBuildHistoryResponse {
    return UpdateBuildHistoryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateBuildHistoryResponse>, I>>(_: I): UpdateBuildHistoryResponse {
    const message = createBaseUpdateBuildHistoryResponse();
    return message;
  },
};

function createBaseDescriptor(): Descriptor {
  return { mediaType: "", digest: "", size: 0, annotations: {} };
}

export const Descriptor = {
  encode(message: Descriptor, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.mediaType !== "") {
      writer.uint32(10).string(message.mediaType);
    }
    if (message.digest !== "") {
      writer.uint32(18).string(message.digest);
    }
    if (message.size !== 0) {
      writer.uint32(24).int64(message.size);
    }
    Object.entries(message.annotations).forEach(([key, value]) => {
      Descriptor_AnnotationsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Descriptor {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.mediaType = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.digest = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.size = longToNumber(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          const entry5 = Descriptor_AnnotationsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.annotations[entry5.key] = entry5.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Descriptor {
    return {
      mediaType: isSet(object.mediaType) ? globalThis.String(object.mediaType) : "",
      digest: isSet(object.digest) ? globalThis.String(object.digest) : "",
      size: isSet(object.size) ? globalThis.Number(object.size) : 0,
      annotations: isObject(object.annotations)
        ? Object.entries(object.annotations).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Descriptor): unknown {
    const obj: any = {};
    if (message.mediaType !== "") {
      obj.mediaType = message.mediaType;
    }
    if (message.digest !== "") {
      obj.digest = message.digest;
    }
    if (message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    if (message.annotations) {
      const entries = Object.entries(message.annotations);
      if (entries.length > 0) {
        obj.annotations = {};
        entries.forEach(([k, v]) => {
          obj.annotations[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Descriptor>, I>>(base?: I): Descriptor {
    return Descriptor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Descriptor>, I>>(object: I): Descriptor {
    const message = createBaseDescriptor();
    message.mediaType = object.mediaType ?? "";
    message.digest = object.digest ?? "";
    message.size = object.size ?? 0;
    message.annotations = Object.entries(object.annotations ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseDescriptor_AnnotationsEntry(): Descriptor_AnnotationsEntry {
  return { key: "", value: "" };
}

export const Descriptor_AnnotationsEntry = {
  encode(message: Descriptor_AnnotationsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Descriptor_AnnotationsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDescriptor_AnnotationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Descriptor_AnnotationsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Descriptor_AnnotationsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Descriptor_AnnotationsEntry>, I>>(base?: I): Descriptor_AnnotationsEntry {
    return Descriptor_AnnotationsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Descriptor_AnnotationsEntry>, I>>(object: I): Descriptor_AnnotationsEntry {
    const message = createBaseDescriptor_AnnotationsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBuildResultInfo(): BuildResultInfo {
  return { ResultDeprecated: undefined, Attestations: [], Results: {} };
}

export const BuildResultInfo = {
  encode(message: BuildResultInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ResultDeprecated !== undefined) {
      Descriptor.encode(message.ResultDeprecated, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.Attestations) {
      Descriptor.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    Object.entries(message.Results).forEach(([key, value]) => {
      BuildResultInfo_ResultsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BuildResultInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildResultInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ResultDeprecated = Descriptor.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.Attestations.push(Descriptor.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = BuildResultInfo_ResultsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.Results[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildResultInfo {
    return {
      ResultDeprecated: isSet(object.ResultDeprecated) ? Descriptor.fromJSON(object.ResultDeprecated) : undefined,
      Attestations: globalThis.Array.isArray(object?.Attestations)
        ? object.Attestations.map((e: any) => Descriptor.fromJSON(e))
        : [],
      Results: isObject(object.Results)
        ? Object.entries(object.Results).reduce<{ [key: number]: Descriptor }>((acc, [key, value]) => {
          acc[globalThis.Number(key)] = Descriptor.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: BuildResultInfo): unknown {
    const obj: any = {};
    if (message.ResultDeprecated !== undefined) {
      obj.ResultDeprecated = Descriptor.toJSON(message.ResultDeprecated);
    }
    if (message.Attestations?.length) {
      obj.Attestations = message.Attestations.map((e) => Descriptor.toJSON(e));
    }
    if (message.Results) {
      const entries = Object.entries(message.Results);
      if (entries.length > 0) {
        obj.Results = {};
        entries.forEach(([k, v]) => {
          obj.Results[k] = Descriptor.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildResultInfo>, I>>(base?: I): BuildResultInfo {
    return BuildResultInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildResultInfo>, I>>(object: I): BuildResultInfo {
    const message = createBaseBuildResultInfo();
    message.ResultDeprecated = (object.ResultDeprecated !== undefined && object.ResultDeprecated !== null)
      ? Descriptor.fromPartial(object.ResultDeprecated)
      : undefined;
    message.Attestations = object.Attestations?.map((e) => Descriptor.fromPartial(e)) || [];
    message.Results = Object.entries(object.Results ?? {}).reduce<{ [key: number]: Descriptor }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[globalThis.Number(key)] = Descriptor.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseBuildResultInfo_ResultsEntry(): BuildResultInfo_ResultsEntry {
  return { key: 0, value: undefined };
}

export const BuildResultInfo_ResultsEntry = {
  encode(message: BuildResultInfo_ResultsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== 0) {
      writer.uint32(8).int64(message.key);
    }
    if (message.value !== undefined) {
      Descriptor.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BuildResultInfo_ResultsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBuildResultInfo_ResultsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.key = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = Descriptor.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BuildResultInfo_ResultsEntry {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value) ? Descriptor.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: BuildResultInfo_ResultsEntry): unknown {
    const obj: any = {};
    if (message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== undefined) {
      obj.value = Descriptor.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BuildResultInfo_ResultsEntry>, I>>(base?: I): BuildResultInfo_ResultsEntry {
    return BuildResultInfo_ResultsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BuildResultInfo_ResultsEntry>, I>>(object: I): BuildResultInfo_ResultsEntry {
    const message = createBaseBuildResultInfo_ResultsEntry();
    message.key = object.key ?? 0;
    message.value = (object.value !== undefined && object.value !== null)
      ? Descriptor.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseExporter(): Exporter {
  return { Type: "", Attrs: {} };
}

export const Exporter = {
  encode(message: Exporter, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.Type !== "") {
      writer.uint32(10).string(message.Type);
    }
    Object.entries(message.Attrs).forEach(([key, value]) => {
      Exporter_AttrsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Exporter {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExporter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.Type = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = Exporter_AttrsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.Attrs[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Exporter {
    return {
      Type: isSet(object.Type) ? globalThis.String(object.Type) : "",
      Attrs: isObject(object.Attrs)
        ? Object.entries(object.Attrs).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Exporter): unknown {
    const obj: any = {};
    if (message.Type !== "") {
      obj.Type = message.Type;
    }
    if (message.Attrs) {
      const entries = Object.entries(message.Attrs);
      if (entries.length > 0) {
        obj.Attrs = {};
        entries.forEach(([k, v]) => {
          obj.Attrs[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Exporter>, I>>(base?: I): Exporter {
    return Exporter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Exporter>, I>>(object: I): Exporter {
    const message = createBaseExporter();
    message.Type = object.Type ?? "";
    message.Attrs = Object.entries(object.Attrs ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseExporter_AttrsEntry(): Exporter_AttrsEntry {
  return { key: "", value: "" };
}

export const Exporter_AttrsEntry = {
  encode(message: Exporter_AttrsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Exporter_AttrsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExporter_AttrsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Exporter_AttrsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Exporter_AttrsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Exporter_AttrsEntry>, I>>(base?: I): Exporter_AttrsEntry {
    return Exporter_AttrsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Exporter_AttrsEntry>, I>>(object: I): Exporter_AttrsEntry {
    const message = createBaseExporter_AttrsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

export interface Control {
  DiskUsage(request: DiskUsageRequest): Promise<DiskUsageResponse>;
  Prune(request: PruneRequest): Observable<UsageRecord>;
  Solve(request: SolveRequest): Promise<SolveResponse>;
  Status(request: StatusRequest): Observable<StatusResponse>;
  Session(request: Observable<BytesMessage>): Observable<BytesMessage>;
  ListWorkers(request: ListWorkersRequest): Promise<ListWorkersResponse>;
  Info(request: InfoRequest): Promise<InfoResponse>;
  ListenBuildHistory(request: BuildHistoryRequest): Observable<BuildHistoryEvent>;
  UpdateBuildHistory(request: UpdateBuildHistoryRequest): Promise<UpdateBuildHistoryResponse>;
}

export const ControlServiceName = "moby.buildkit.v1.Control";
export class ControlClientImpl implements Control {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || ControlServiceName;
    this.rpc = rpc;
    this.DiskUsage = this.DiskUsage.bind(this);
    this.Prune = this.Prune.bind(this);
    this.Solve = this.Solve.bind(this);
    this.Status = this.Status.bind(this);
    this.Session = this.Session.bind(this);
    this.ListWorkers = this.ListWorkers.bind(this);
    this.Info = this.Info.bind(this);
    this.ListenBuildHistory = this.ListenBuildHistory.bind(this);
    this.UpdateBuildHistory = this.UpdateBuildHistory.bind(this);
  }
  DiskUsage(request: DiskUsageRequest): Promise<DiskUsageResponse> {
    const data = DiskUsageRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DiskUsage", data);
    return promise.then((data) => DiskUsageResponse.decode(_m0.Reader.create(data)));
  }

  Prune(request: PruneRequest): Observable<UsageRecord> {
    const data = PruneRequest.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, "Prune", data);
    return result.pipe(map((data) => UsageRecord.decode(_m0.Reader.create(data))));
  }

  Solve(request: SolveRequest): Promise<SolveResponse> {
    const data = SolveRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Solve", data);
    return promise.then((data) => SolveResponse.decode(_m0.Reader.create(data)));
  }

  Status(request: StatusRequest): Observable<StatusResponse> {
    const data = StatusRequest.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, "Status", data);
    return result.pipe(map((data) => StatusResponse.decode(_m0.Reader.create(data))));
  }

  Session(request: Observable<BytesMessage>): Observable<BytesMessage> {
    const data = request.pipe(map((request) => BytesMessage.encode(request).finish()));
    const result = this.rpc.bidirectionalStreamingRequest(this.service, "Session", data);
    return result.pipe(map((data) => BytesMessage.decode(_m0.Reader.create(data))));
  }

  ListWorkers(request: ListWorkersRequest): Promise<ListWorkersResponse> {
    const data = ListWorkersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ListWorkers", data);
    return promise.then((data) => ListWorkersResponse.decode(_m0.Reader.create(data)));
  }

  Info(request: InfoRequest): Promise<InfoResponse> {
    const data = InfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Info", data);
    return promise.then((data) => InfoResponse.decode(_m0.Reader.create(data)));
  }

  ListenBuildHistory(request: BuildHistoryRequest): Observable<BuildHistoryEvent> {
    const data = BuildHistoryRequest.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, "ListenBuildHistory", data);
    return result.pipe(map((data) => BuildHistoryEvent.decode(_m0.Reader.create(data))));
  }

  UpdateBuildHistory(request: UpdateBuildHistoryRequest): Promise<UpdateBuildHistoryResponse> {
    const data = UpdateBuildHistoryRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateBuildHistory", data);
    return promise.then((data) => UpdateBuildHistoryResponse.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
  clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Promise<Uint8Array>;
  serverStreamingRequest(service: string, method: string, data: Uint8Array): Observable<Uint8Array>;
  bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Observable<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
