// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.1
//   protoc               v3.11.4
// source: github.com/moby/buildkit/sourcepolicy/pb/policy.proto

/* eslint-disable */
import * as _m0 from "protobufjs/minimal";
import Long = require("long");

export const protobufPackage = "moby.buildkit.v1.sourcepolicy";

/** PolicyAction defines the action to take when a source is matched */
export enum PolicyAction {
  ALLOW = 0,
  DENY = 1,
  CONVERT = 2,
  UNRECOGNIZED = -1,
}

export function policyActionFromJSON(object: any): PolicyAction {
  switch (object) {
    case 0:
    case "ALLOW":
      return PolicyAction.ALLOW;
    case 1:
    case "DENY":
      return PolicyAction.DENY;
    case 2:
    case "CONVERT":
      return PolicyAction.CONVERT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PolicyAction.UNRECOGNIZED;
  }
}

export function policyActionToJSON(object: PolicyAction): string {
  switch (object) {
    case PolicyAction.ALLOW:
      return "ALLOW";
    case PolicyAction.DENY:
      return "DENY";
    case PolicyAction.CONVERT:
      return "CONVERT";
    case PolicyAction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** AttrMatch defines the condition to match a source attribute */
export enum AttrMatch {
  EQUAL = 0,
  NOTEQUAL = 1,
  MATCHES = 2,
  UNRECOGNIZED = -1,
}

export function attrMatchFromJSON(object: any): AttrMatch {
  switch (object) {
    case 0:
    case "EQUAL":
      return AttrMatch.EQUAL;
    case 1:
    case "NOTEQUAL":
      return AttrMatch.NOTEQUAL;
    case 2:
    case "MATCHES":
      return AttrMatch.MATCHES;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AttrMatch.UNRECOGNIZED;
  }
}

export function attrMatchToJSON(object: AttrMatch): string {
  switch (object) {
    case AttrMatch.EQUAL:
      return "EQUAL";
    case AttrMatch.NOTEQUAL:
      return "NOTEQUAL";
    case AttrMatch.MATCHES:
      return "MATCHES";
    case AttrMatch.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Match type is used to determine how a rule source is matched */
export enum MatchType {
  /**
   * WILDCARD - WILDCARD is the default matching type.
   * It may first attempt to due an exact match but will follow up with a wildcard match
   * For something more powerful, use REGEX
   */
  WILDCARD = 0,
  /** EXACT - EXACT treats the source identifier as a litteral string match */
  EXACT = 1,
  /**
   * REGEX - REGEX treats the source identifier as a regular expression
   * With regex matching you can also use match groups to replace values in the destination identifier
   */
  REGEX = 2,
  UNRECOGNIZED = -1,
}

export function matchTypeFromJSON(object: any): MatchType {
  switch (object) {
    case 0:
    case "WILDCARD":
      return MatchType.WILDCARD;
    case 1:
    case "EXACT":
      return MatchType.EXACT;
    case 2:
    case "REGEX":
      return MatchType.REGEX;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MatchType.UNRECOGNIZED;
  }
}

export function matchTypeToJSON(object: MatchType): string {
  switch (object) {
    case MatchType.WILDCARD:
      return "WILDCARD";
    case MatchType.EXACT:
      return "EXACT";
    case MatchType.REGEX:
      return "REGEX";
    case MatchType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Rule defines the action(s) to take when a source is matched */
export interface Rule {
  action: PolicyAction;
  selector: Selector | undefined;
  updates: Update | undefined;
}

/** Update contains updates to the matched build step after rule is applied */
export interface Update {
  identifier: string;
  attrs: { [key: string]: string };
}

export interface Update_AttrsEntry {
  key: string;
  value: string;
}

/** Selector identifies a source to match a policy to */
export interface Selector {
  identifier: string;
  /** MatchType is the type of match to perform on the source identifier */
  matchType: MatchType;
  constraints: AttrConstraint[];
}

/** AttrConstraint defines a constraint on a source attribute */
export interface AttrConstraint {
  key: string;
  value: string;
  condition: AttrMatch;
}

/** Policy is the list of rules the policy engine will perform */
export interface Policy {
  /** Currently 1 */
  version: number;
  rules: Rule[];
}

function createBaseRule(): Rule {
  return { action: 0, selector: undefined, updates: undefined };
}

export const Rule = {
  encode(message: Rule, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.action !== 0) {
      writer.uint32(8).int32(message.action);
    }
    if (message.selector !== undefined) {
      Selector.encode(message.selector, writer.uint32(18).fork()).ldelim();
    }
    if (message.updates !== undefined) {
      Update.encode(message.updates, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Rule {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.selector = Selector.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.updates = Update.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Rule {
    return {
      action: isSet(object.action) ? policyActionFromJSON(object.action) : 0,
      selector: isSet(object.selector) ? Selector.fromJSON(object.selector) : undefined,
      updates: isSet(object.updates) ? Update.fromJSON(object.updates) : undefined,
    };
  },

  toJSON(message: Rule): unknown {
    const obj: any = {};
    if (message.action !== 0) {
      obj.action = policyActionToJSON(message.action);
    }
    if (message.selector !== undefined) {
      obj.selector = Selector.toJSON(message.selector);
    }
    if (message.updates !== undefined) {
      obj.updates = Update.toJSON(message.updates);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Rule>, I>>(base?: I): Rule {
    return Rule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Rule>, I>>(object: I): Rule {
    const message = createBaseRule();
    message.action = object.action ?? 0;
    message.selector = (object.selector !== undefined && object.selector !== null)
      ? Selector.fromPartial(object.selector)
      : undefined;
    message.updates = (object.updates !== undefined && object.updates !== null)
      ? Update.fromPartial(object.updates)
      : undefined;
    return message;
  },
};

function createBaseUpdate(): Update {
  return { identifier: "", attrs: {} };
}

export const Update = {
  encode(message: Update, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.identifier !== "") {
      writer.uint32(10).string(message.identifier);
    }
    Object.entries(message.attrs).forEach(([key, value]) => {
      Update_AttrsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Update {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.identifier = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          const entry2 = Update_AttrsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.attrs[entry2.key] = entry2.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Update {
    return {
      identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : "",
      attrs: isObject(object.attrs)
        ? Object.entries(object.attrs).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Update): unknown {
    const obj: any = {};
    if (message.identifier !== "") {
      obj.identifier = message.identifier;
    }
    if (message.attrs) {
      const entries = Object.entries(message.attrs);
      if (entries.length > 0) {
        obj.attrs = {};
        entries.forEach(([k, v]) => {
          obj.attrs[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Update>, I>>(base?: I): Update {
    return Update.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Update>, I>>(object: I): Update {
    const message = createBaseUpdate();
    message.identifier = object.identifier ?? "";
    message.attrs = Object.entries(object.attrs ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseUpdate_AttrsEntry(): Update_AttrsEntry {
  return { key: "", value: "" };
}

export const Update_AttrsEntry = {
  encode(message: Update_AttrsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Update_AttrsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdate_AttrsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Update_AttrsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Update_AttrsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Update_AttrsEntry>, I>>(base?: I): Update_AttrsEntry {
    return Update_AttrsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Update_AttrsEntry>, I>>(object: I): Update_AttrsEntry {
    const message = createBaseUpdate_AttrsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSelector(): Selector {
  return { identifier: "", matchType: 0, constraints: [] };
}

export const Selector = {
  encode(message: Selector, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.identifier !== "") {
      writer.uint32(10).string(message.identifier);
    }
    if (message.matchType !== 0) {
      writer.uint32(16).int32(message.matchType);
    }
    for (const v of message.constraints) {
      AttrConstraint.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Selector {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSelector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.identifier = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.matchType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.constraints.push(AttrConstraint.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Selector {
    return {
      identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : "",
      matchType: isSet(object.matchType) ? matchTypeFromJSON(object.matchType) : 0,
      constraints: globalThis.Array.isArray(object?.constraints)
        ? object.constraints.map((e: any) => AttrConstraint.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Selector): unknown {
    const obj: any = {};
    if (message.identifier !== "") {
      obj.identifier = message.identifier;
    }
    if (message.matchType !== 0) {
      obj.matchType = matchTypeToJSON(message.matchType);
    }
    if (message.constraints?.length) {
      obj.constraints = message.constraints.map((e) => AttrConstraint.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Selector>, I>>(base?: I): Selector {
    return Selector.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Selector>, I>>(object: I): Selector {
    const message = createBaseSelector();
    message.identifier = object.identifier ?? "";
    message.matchType = object.matchType ?? 0;
    message.constraints = object.constraints?.map((e) => AttrConstraint.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAttrConstraint(): AttrConstraint {
  return { key: "", value: "", condition: 0 };
}

export const AttrConstraint = {
  encode(message: AttrConstraint, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.condition !== 0) {
      writer.uint32(24).int32(message.condition);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AttrConstraint {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttrConstraint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.condition = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttrConstraint {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      condition: isSet(object.condition) ? attrMatchFromJSON(object.condition) : 0,
    };
  },

  toJSON(message: AttrConstraint): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.condition !== 0) {
      obj.condition = attrMatchToJSON(message.condition);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AttrConstraint>, I>>(base?: I): AttrConstraint {
    return AttrConstraint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AttrConstraint>, I>>(object: I): AttrConstraint {
    const message = createBaseAttrConstraint();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    message.condition = object.condition ?? 0;
    return message;
  },
};

function createBasePolicy(): Policy {
  return { version: 0, rules: [] };
}

export const Policy = {
  encode(message: Policy, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.version !== 0) {
      writer.uint32(8).int64(message.version);
    }
    for (const v of message.rules) {
      Rule.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Policy {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.version = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.rules.push(Rule.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Policy {
    return {
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      rules: globalThis.Array.isArray(object?.rules) ? object.rules.map((e: any) => Rule.fromJSON(e)) : [],
    };
  },

  toJSON(message: Policy): unknown {
    const obj: any = {};
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => Rule.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Policy>, I>>(base?: I): Policy {
    return Policy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Policy>, I>>(object: I): Policy {
    const message = createBasePolicy();
    message.version = object.version ?? 0;
    message.rules = object.rules?.map((e) => Rule.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
